In this section we describe the necessary technical details about \eth{}'s implementation, and how we exploit them for compression.
We decided to work with the \eth{} blockchain export format.
The format is standard among all \eth{} clients and can be used for backup/restore purposes.

The exported blockchain file is a simple concatenation of a series of blocks.
Each block contains a header and a list of transactions included in the block.
Each \eth{} block also include a list of {\em uncles}, which are special parent blocks not part of the main chain.
Uncles are specific to \eth{} to encourage mining while accounting for the blockchain's short block time.
We now explain each of these components and discuss compression opportunities in more detail.

%A block is comprised of a block header, ommer (parent) block headers and a series of transactions. 
%A block header stores cryptographic hashes of all transactions in the block as well as of previous and parent blocks.
%These hashes play an important role for verifying the validity of blocks.
%It might seem that there is not enough information to compress these random bits. 
%The block hashes, however, have a fixed number of leading zeros and
%can therefore be encoded more efficiently.
%Also, a closer inspection at the block header reveals that
%some information is either redundant or can be computed given other fields of the block.
%We explain how to exploit this redundancy to efficiently encode the block information.

\subsection{Block Header}
The block header is the metadata portion of an \eth{} block. The block header contain important
information about the content of the block, and the hash of the header is usually regarded as the ``block hash''
used in proof-of-work validation.
Block headers have the following format:

\begin{table}[H]
	\centering
\begin{tabular}{>{\bfseries}l c l}
 parentHash&:& Hash of the previous block in the main chain\\
 uncleHash&:& Hash of the list of uncles\\
 stateRoot&:& Merkle-tree root for fast verification of transactions\\
 transactionsRoot&:& Hash of the list of transactions\\
 coinbase&:& Address to which the coinbase reward (mining reward) is paid to\\
 logsBloom&:& Bloom filter for log entries\\
 difficulty&:& Proof-of-work difficulty of this block\\
 number&:& Height of this block\\
 gasLimit&:& Scalar value limiting the gas expenditure\\
 gasUsed&:& Scalar value indicating the total gas used by all transactions in the block\\
 timestamp&:&\\
 extraData&:&\\
 mixHash&:& Special hash for fast verification of block difficulty\\
 nonce&:& The proof of work\\
\end{tabular}
\end{table}

The block header contains many redundant information and therefore presents opportunities for efficient encoding.
The \textbf{difficulty} field, for exmaple, can be computed using the following equation according to~\cite{ethereum}.

$$
D_{c} = D_{p} + \dfrac{D_{p}}{2^{11}\cdot\max\left(\dfrac{1 - (ts_{c} - ts_{p})}{10}, -99\right)} + 2^{b/10^5-2}
$$

where $ts$ denotes timestamps, subscripts $c$ and $p$ denote current and parent blocks respectively, and $b$ is the block number.
This suggests that we don't have to store difficulty in the block headers.
Fields like \textbf{transactionsRoot} and \textbf{parentHash} are also redundant.
\textbf{transactionsRoot} can be deterministically computed from the list of transactions included in the block,
and \textbf{parentHash} can be reconstructed by locating the parent block by block height and re-hashing the header.

\textbf{logsBloom} is a Bloom filter used as a digest of all logs generated by transactions.
It is used to validate the logging behavior of smart contract transactions. The Bloom filter occupies 256 bytes,
but according to our observation most of the bytes are zero. This again presents opportunities for compression.
In our implementation, we used run-length encoding to encode such zero bytes in the Bloom filter.

\subsection{Transaction}

A transaction is a signed message indicating some action like account transfer or contract execution.
Transactions are much more compressible and can be a major source of compression gains.
Each transaction has the following format:

\begin{table}[H]
	\centering
	\begin{tabular}{>{\bfseries}l c p{0.8\textwidth}}
  nonce&:& A scalar value representing number of transactions associated with this account\\
	gasPrice&:& \par{Default value is $0.02\times10^{12}$ Wei. Though clients can set their own gasPrice, most of the transactions use default value suggesting the high probability of its occurance} \\
  gasLimit&:& Maximum gas that can be used for executing this transaction\\
  to&:& Receiver's 160-bit address. The address is empty for contract creation.\\
  payload&:& Additional data for contract-related transactions\\
  value&:& Wei being transferred to the recipient. For contract-related transactions, this field is zero.\\
  v, r, s&:& Cryptographic signature of the transaction\\
\end{tabular}
\end{table}

The \textbf{payload} field contains EVM bytecode as well as message call data for contract-related transactions,
both are highly compressable. We decided to use Huffman encoding to reduce the footprint of EVM bytecode,
and apply the more sophiscated gzip compression on top of that.
For message call transactions, the \textbf{payload} field contains message call data that represent a method ID and
parameters supplied to the contract method being invoked.
Message call data have a large number of zero bytes, because \eth{} uses 256-bit integers,
while most smart contract still only use the lower 64 bits.
We also use run-length encoding to encode the repeating zero bytes in message call data.
%Additionally, a Contract Creation transaction has an \textbf{init} field containing the EVM bytecode for initializing the contract.
%We propose to compress the EVM bytecode using techniques presented in Section~\ref{sec:evmcompress}.
%A Message Call transaction has \textbf{data} field that contains the inputs of the message call: a method ID and parameters supplied to the invoked method.
%Existing transactions suggest that most of the inputs are going to have a high number of 0's~\cite{ethtx}. 
%This is because \eth{} uses 256-bit big integers, but most of the transactions limit themselves to using 64-bit integers.
%This suggests that small numbers can be encoded efficiently.

\subsection{Other Considerations}

We decided not to apply any special treatment to uncles due to their rareness in the blockchain.

We also note the additional compression opportunities by reorganizing the blockchain.
We propose to reorganize the blockchain by grouping blocks according to their coinbase reward addresses.
Due to effects of pooled mining, most blocks are mined by a relatively small number of mining pools.
This means that a large number blocks can potentially have the same coinbase reward address.
Reorganizing the blocks by coinbase reward addresses avoid repeating such information in each block.
Within each block, we also propose to organize transactions by their recipient addresses, so that
transactions to the same address will only have the recipient address written in the block once.

We also studied the possibility of grouping transactions by their ``from'' addresses.
Unfortunately the ``from'' address is encoded in the signature, and it's impossible to
separate signatures from individual transactions.
